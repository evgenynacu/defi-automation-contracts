{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {ContextUpgradeable} from \"../../utils/ContextUpgradeable.sol\";\nimport {IERC20Errors} from \"@openzeppelin/contracts/interfaces/draft-IERC6093.sol\";\nimport {Initializable} from \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata, IERC20Errors {\n    /// @custom:storage-location erc7201:openzeppelin.storage.ERC20\n    struct ERC20Storage {\n        mapping(address account => uint256) _balances;\n\n        mapping(address account => mapping(address spender => uint256)) _allowances;\n\n        uint256 _totalSupply;\n\n        string _name;\n        string _symbol;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.ERC20\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant ERC20StorageLocation = 0x52c63247e1f47db19d5ce0460030c497f067ca4cebf71ba98eeadabe20bace00;\n\n    function _getERC20Storage() private pure returns (ERC20Storage storage $) {\n        assembly {\n            $.slot := ERC20StorageLocation\n        }\n    }\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        ERC20Storage storage $ = _getERC20Storage();\n        $._name = name_;\n        $._symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        ERC20Storage storage $ = _getERC20Storage();\n        return $._allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            $._totalSupply += value;\n        } else {\n            uint256 fromBalance = $._balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                $._balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                $._totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                $._balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        ERC20Storage storage $ = _getERC20Storage();\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        $._allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\nimport {Initializable} from \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/interfaces/tokan/TokanGauge.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface TokanGauge {\n    function getReward() external;\n    function earned(address account) external view returns (uint256);\n    function deposit(uint256 amount) external;\n    function balanceOf(address _account) external view returns (uint);\n    function withdraw(uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/tokan/TokanPair.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface TokanPair is IERC20 {\n\n    function getReserves() external view returns (uint _reserve0, uint _reserve1, uint _blockTimestampLast);\n    function getAmountOut(uint, address) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/tokan/TokanRouter.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface TokanRouter {\n    struct Route {\n        address from;\n        address to;\n        bool stable;\n    }\n\n    function swapExactTokensForTokens(uint amountIn,uint amountOutMin, Route[] calldata routes,address to,uint deadline) external returns (uint[] memory amounts);\n\n    function quoteAddLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 amountADesired,\n        uint256 amountBDesired\n    ) external view returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function getAmountsOut(uint256 amountIn, Route[] memory routes) external view returns (uint256[] memory amounts);\n\n    function quoteRemoveLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 liquidity\n    ) external view returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n}\n"
    },
    "contracts/v2/DexInvestment.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./Investment.sol\";\n\n/// @notice Represents on-chain DEX investment (in liquidity pair)\nabstract contract DexInvestment is Investment {\n    IERC20 public secondary;\n    IERC20 public reward;\n\n    function __DexInvestment_init_unchained(IERC20 _secondary, IERC20 _reward) internal onlyInitializing {\n        secondary = _secondary;\n        reward = _reward;\n    }\n\n    /// @notice Adds liquidity to DEX pair: calculates amount to exchange, then adds liqudity on both sides\n    /// @param amount Amount of primary token to deposit\n    /// @return toMint Number of tokens to be minted after depositing funds\n    function _deposit(uint amount) internal override returns (uint toMint) {\n        (uint dA, uint B) = _depositToDex(amount);\n\n        uint _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            toMint = amount * 10 ** 18/ _getDecimalsA();\n        } else {\n            (uint ownedRewards, uint unclaimedRewards) = _getAllRewards();\n            emit TestValue(\"ownedRewards\", ownedRewards);\n            emit TestValue(\"unclaimedRewards\", unclaimedRewards);\n\n            uint totalValue = _calculateTotalValue();\n            emit TestValue(\"total\", totalValue);\n\n            /// @dev calculating deposited assets value\n            uint depositedValue = (amount - dA) + _getPrimaryOut(B);\n            emit TestValue(\"deposited\", depositedValue);\n            toMint = depositedValue * totalSupply() / (totalValue - depositedValue);\n        }\n    }\n\n    // @notice Prepares withdrawal of the liquidity. Takes proportionally all values from: owned assets, invested, rewards\n    function _prepareWithdraw(uint amount, uint totalSupply) internal override returns (uint readyToWithdraw) {\n        uint userA = primary.balanceOf(address(this)) * amount / totalSupply;\n        uint userB = secondary.balanceOf(address(this)) * amount / totalSupply;\n        (uint amountA, uint amountB) = _withdrawFromDex(amount, totalSupply);\n\n        // @dev first just sum owned A and extracted from DEX liquidity\n        readyToWithdraw = userA + amountA;\n        emit TestValue(\"ready to withdraw primary\", readyToWithdraw);\n        // @dev then exchange secondary to primary and add it as well\n        readyToWithdraw += _exchangeSecondary(userB + amountB);\n        emit TestValue(\"ready to withdraw +secondary\", readyToWithdraw);\n\n        if (address(reward) != 0x0000000000000000000000000000000000000000) {\n            emit TestValue(\"total rewards before\", reward.balanceOf(address(this)));\n            _receiveRewards();\n            uint rewards = reward.balanceOf(address(this));\n            emit TestValue(\"total rewards\", rewards);\n            uint userRewards = rewards * amount / totalSupply;\n            readyToWithdraw += _exchangeRewards(userRewards);\n            emit TestValue(\"ready to withdraw +rewards\", readyToWithdraw);\n            emit TestValue(\"total rewards after\", reward.balanceOf(address(this)));\n        }\n    }\n\n    /// @notice Reinvests everything's owned into DEX (including rewards)\n    /// @dev it does it easy way - just exchanges everything to primary first and then runs part of deposit function\n    function reinvest(bool reinvestSecondary, bool reinvestRewards) external {\n        if (reinvestSecondary) {\n            uint ownedB = secondary.balanceOf(address(this));\n            _exchangeSecondary(ownedB);\n        }\n\n        if (reinvestRewards && address(reward) != 0x0000000000000000000000000000000000000000) {\n            _receiveRewards();\n            uint rewards = reward.balanceOf(address(this));\n\n            if (rewards != 0) {\n                _exchangeRewards(rewards);\n            }\n        }\n\n        uint amount = primary.balanceOf(address(this));\n        _depositToDex(amount);\n    }\n\n    function _depositToDex(uint amount) internal returns (uint dA, uint B) {\n        dA = _calculateDeltaA(amount);\n\n        /// @dev B = amount of secondary tokens which are exchanged\n        B = _exchangePrimary(dA);\n\n        /// @dev put into the liquidity pool\n        _putIntoDex(amount - dA, B);\n    }\n\n    function _calculateTotalValue() internal view override returns (uint total) {\n        (uint amountA, uint amountB, uint rewards) = _calculateAllAssets();\n        total = amountA + _getPrimaryOut(amountB) + _getRewardValue(rewards);\n    }\n\n    /// @dev Calculates all assets owned by the contract\n    function _calculateAllAssets() internal view returns (uint amountA, uint amountB, uint rewards) {\n        uint ownedA = primary.balanceOf(address(this));\n        uint ownedB = secondary.balanceOf(address(this));\n        (uint investedA, uint investedB) = _getDexLiquidity();\n        (uint ownedRewards, uint unclaimedRewards) = _getAllRewards();\n        amountA = ownedA + investedA;\n        amountB = ownedB + investedB;\n        rewards = ownedRewards + unclaimedRewards;\n    }\n\n    /// @notice Calculates A to exchange to B to add as DEX liquidity\n    /// @dev This function works under assumption that deposited liquidity is too small to change balance of reserves\n    /// @dev Definitions: Ra = Reserves of A(primary), Rb = Reserves of B(secondary), X = amount, dX = X to exchange\n    /// @dev P = amount out for B (if amount of A = 1) (So P = Price)\n    /// @dev this holds: Ra/Rb = (A - dA) / dA * P\n    /// @dev In the result dA = A * Rb / (Ra * P + Rb)\n    function _calculateDeltaA(uint A) internal view returns (uint dA) {\n        uint decimalsA = _getDecimalsA();\n        uint P = _getSecondaryOut(decimalsA);\n        (uint Ra, uint Rb) = _getReserves();\n        return A * Rb / (Ra * P / decimalsA + Rb);\n    }\n\n    /// @notice Gets rewards (owned and unclaimed)\n    function _getAllRewards() internal view returns (uint owned, uint unclaimed) {\n        if (address(reward) == 0x0000000000000000000000000000000000000000) {\n            owned = 0;\n            unclaimed = 0;\n        } else {\n            owned = reward.balanceOf(address(this));\n            unclaimed = _getRewards();\n        }\n    }\n\n    /// @notice Gets reserves for both assets in the pool\n    function _getReserves() internal virtual view returns (uint reserveA, uint reserveB);\n\n    /// @notice Gets 10**decimals for primary asset\n    function _getDecimalsA() internal view virtual returns (uint decimalsA);\n\n    /// @notice Calculates how much secondary tokens will be returned if primaryAmount exchanged\n    function _getSecondaryOut(uint primaryAmount) internal view virtual returns (uint secondaryAmount);\n\n    /// @notice Calculates how much primary tokens will be returned if secondaryAmount exchanged\n    function _getPrimaryOut(uint secondaryAmount) internal view virtual returns (uint primaryAmount);\n\n    /// @notice Calculates how much primary tokens will be returned if reward exchanged\n    function _getRewardValue(uint rewardAmount) internal view virtual returns (uint primaryAmount);\n\n    /// @notice Exchanges primary token and gets secondary token\n    function _exchangePrimary(uint amount) internal virtual returns (uint out);\n\n    /// @notice Exchanges secondary token and gets primary token\n    function _exchangeSecondary(uint amount) internal virtual returns (uint out);\n\n    /// @notice Exchanges secondary token and gets primary token\n    function _exchangeRewards(uint amount) internal virtual returns (uint out);\n\n    /// @notice Returns liquidity currently in the DEX Pool\n    function _getDexLiquidity() internal view virtual returns (uint amountA, uint amountB);\n\n    /// @notice Returns liquidity currently in the DEX Pool\n    function _getRewards() internal view virtual returns (uint amount);\n\n    /// @notice Receives rewards and transfers them to this smart-contract\n    function _receiveRewards() internal virtual;\n\n    /// @notice Adds liquidity into DEX pool\n    function _putIntoDex(uint amountA, uint amountB) internal virtual returns (uint resultA, uint resultB);\n\n    /// @notice Removes part of the liquidity from DEX (amount/totalSupply)\n    function _withdrawFromDex(uint amount, uint totalSupply) internal virtual returns (uint amountA, uint amountB);\n}\n"
    },
    "contracts/v2/Investment.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\n\n/// @dev Represents on-chain investment. This covers any investment where you deposit single token -> you get another ERC-20 in return.\n/// @dev Later you can redeem original investment token\nabstract contract Investment is ERC20Upgradeable {\n\n    IERC20 public primary;\n\n    event TestValue(string title, uint value);\n\n    function __SingleTokenInvestment_init_unchained(IERC20 _primary) internal onlyInitializing {\n        primary = _primary;\n    }\n\n    /// @notice calculates value for the wallet denominated in primary tokens\n    function calculateValue(address wallet) public view returns (uint value) {\n        uint _totalSupply = totalSupply();\n        uint _balance = balanceOf(wallet);\n        uint _totalValue = _calculateTotalValue();\n        return _totalValue * _balance / _totalSupply;\n    }\n\n    /// @notice Calculates total assets denominated in primary tokens\n    function _calculateTotalValue() internal view virtual returns (uint total);\n\n    /// @dev Deposits primary token and issues this token\n    function deposit(uint amount) external returns (uint issued) {\n        require(amount > 0, \"Zero amount\");\n        require(primary.transferFrom(_msgSender(), address(this), amount), \"Transfer failed\");\n        uint toMint = _deposit(amount);\n        _mint(_msgSender(), toMint);\n        return toMint;\n    }\n\n    /// @dev Burns this token and withdraws primary investment token\n    function withdraw(uint amount) external returns (uint withdrawn) {\n        require(amount > 0, \"Zero amount\");\n\n        uint _totalSupply = totalSupply();\n        _burn(_msgSender(), amount);\n\n        uint toWithdraw = _prepareWithdraw(amount, _totalSupply);\n        require(primary.transfer(_msgSender(), toWithdraw), \"Transfer failed\");\n        return toWithdraw;\n    }\n\n    /// @dev Prepares liquidity to be withdrawn. Returns amount of tokens to withdraw\n    function _prepareWithdraw(uint amount, uint totalSupply) internal virtual returns (uint readyToWithdraw);\n\n    function _deposit(uint amount) internal virtual returns (uint toMint);\n}\n"
    },
    "contracts/v2/TokanDexInvestment.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"./DexInvestment.sol\";\nimport \"../interfaces/tokan/TokanPair.sol\";\nimport \"../interfaces/tokan/TokanRouter.sol\";\nimport \"../interfaces/tokan/TokanGauge.sol\";\n\ncontract TokanDexInvestment is DexInvestment {\n    TokanRouter public router;\n    TokanPair public pair;\n    TokanGauge public gauge;\n    bool public stable;\n    uint private decimalsA;\n    TokanRouter.Route[] public rewardExchangeRoute;\n\n    struct TokanDexInvestmentConfig {\n        TokanRouter router;\n        TokanPair pair;\n        TokanGauge gauge;\n        uint decimalsA;\n        bool stable;\n        TokanRouter.Route[] rewardExchangeRoute;\n    }\n\n    uint constant private UINT_MAX = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    function __TokanDexInvestment_init(string memory name_, string memory symbol_, IERC20 _primary, IERC20 _secondary, IERC20 _reward, TokanDexInvestmentConfig memory config) initializer external {\n        __Context_init_unchained();\n        __ERC20_init_unchained(name_, symbol_);\n        __SingleTokenInvestment_init_unchained(_primary);\n        __DexInvestment_init_unchained(_secondary, _reward);\n        __TokanDexInvestment_init_unchained(config);\n        approveAll();\n    }\n\n    function __TokanDexInvestment_init_unchained(TokanDexInvestmentConfig memory config) internal onlyInitializing {\n        router = config.router;\n        pair = config.pair;\n        gauge = config.gauge;\n        decimalsA = config.decimalsA;\n        stable = config.stable;\n        for (uint i = 0; i < config.rewardExchangeRoute.length; i++) {\n            TokanRouter.Route memory route = config.rewardExchangeRoute[i];\n            rewardExchangeRoute.push(route);\n        }\n    }\n\n    function approveAll() public {\n        primary.approve(address(router), UINT_MAX);\n        secondary.approve(address(router), UINT_MAX);\n        pair.approve(address(gauge), UINT_MAX);\n        pair.approve(address(router), UINT_MAX);\n        reward.approve(address(router), UINT_MAX);\n    }\n\n    /// @notice Gets reserves for both assets in the pool\n    function _getReserves() internal override view returns (uint reserveA, uint reserveB) {\n        (reserveA, reserveB,) = pair.getReserves();\n    }\n\n    /// @notice Gets 10**decimals for primary asset\n    function _getDecimalsA() internal view override returns (uint) {\n        return decimalsA;\n    }\n\n    /// @notice Calculates how much secondary tokens will be returned if mainAmount exchanged\n    function _getSecondaryOut(uint mainAmount) internal view override returns (uint secondaryAmount) {\n        return pair.getAmountOut(mainAmount, address(primary));\n    }\n\n    /// @notice Calculates how much primary tokens will be returned if secondaryAmount exchanged\n    function _getPrimaryOut(uint secondaryAmount) internal view override returns (uint primaryAmount) {\n        return pair.getAmountOut(secondaryAmount, address(secondary));\n    }\n\n    /// @notice Exchanges main and gets secondary token\n    function _exchangePrimary(uint amount) internal override returns (uint out) {\n        TokanRouter.Route[] memory route = new TokanRouter.Route[](1);\n        route[0] = TokanRouter.Route({from: address(primary), to: address(secondary), stable: stable});\n        uint[] memory amounts = router.swapExactTokensForTokens(amount, _getSecondaryOut(amount), route, address(this), block.timestamp);\n        return amounts[1];\n    }\n\n    /// @notice Exchanges secondary token and gets primary token\n    function _exchangeSecondary(uint amount) internal override returns (uint out) {\n        TokanRouter.Route[] memory route = new TokanRouter.Route[](1);\n        route[0] = TokanRouter.Route({from: address(secondary), to: address(primary), stable: stable});\n        uint[] memory amounts = router.swapExactTokensForTokens(amount, _getPrimaryOut(amount), route, address(this), block.timestamp);\n        return amounts[1];\n    }\n\n    /// @notice Exchanges secondary token and gets primary token\n    function _exchangeRewards(uint amount) internal override returns (uint out) {\n        uint _value = _getRewardValue(amount);\n        emit TestValue(\"reward value\", _value);\n        uint[] memory amounts = router.swapExactTokensForTokens(amount, _value, rewardExchangeRoute, address(this), block.timestamp);\n        return amounts[rewardExchangeRoute.length];\n    }\n\n    /// @notice Returns liquidity currently in the DEX Pool\n    function _getDexLiquidity() internal view override returns (uint amountA, uint amountB) {\n        // @dev liquidity - total amount of Pair tokens, deposited in Gauge for this Pool\n        // @dev potentially some amount can be owned by this contract and not in the gauge, but will always put Pair tokens into the gauge, so should not happen\n        uint liquidity = gauge.balanceOf(address(this));\n\n        // @dev _balance0, _balance1 - how much primary and secondary tokens pair owns (total DEX liquidity)\n        uint256 _balance0 = primary.balanceOf(address(pair));\n        uint256 _balance1 = secondary.balanceOf(address(pair));\n\n        // @dev _totalSupply - how much of DEX tokens issued\n        uint256 _totalSupply = pair.totalSupply();\n        amountA = (liquidity * _balance0) / _totalSupply;\n        amountB = (liquidity * _balance1) / _totalSupply;\n    }\n\n    /// @notice Returns liquidity currently in the DEX Pool\n    function _getRewards() internal view override returns (uint amount) {\n        return gauge.earned(address(this));\n    }\n\n    /// @notice Adds liquidity into DEX pool\n    function _putIntoDex(uint amountA, uint amountB) internal override returns (uint resultA, uint resultB) {\n        emit TestValue(\"amountA\", amountA);\n        emit TestValue(\"amountB\", amountB);\n        bool _stable = stable;\n        (uint amountAQuote, uint amountBQuote,) = router.quoteAddLiquidity(address(primary), address(secondary), _stable, amountA, amountB);\n        emit TestValue(\"amountAQuote\", amountAQuote);\n        emit TestValue(\"amountBQuote\", amountBQuote);\n        (uint addedA, uint addedB, uint liquidity) = router.addLiquidity(address(primary), address(secondary), _stable, amountAQuote, amountBQuote, amountAQuote, amountBQuote, address(this), block.timestamp);\n        emit TestValue(\"addedA\", addedA);\n        emit TestValue(\"addedB\", addedB);\n        emit TestValue(\"liquidity\", liquidity);\n\n        resultA = addedA;\n        resultB = addedB;\n\n        gauge.deposit(liquidity);\n    }\n\n    /// @notice Calculates how much primary tokens will be returned if reward exchanged\n    function _getRewardValue(uint rewardAmount) internal view override returns (uint primaryAmount) {\n        uint[] memory amounts = router.getAmountsOut(rewardAmount, rewardExchangeRoute);\n        return amounts[amounts.length - 1];\n    }\n\n    /// @notice Receives rewards and transfers them to this smart-contract\n    function _receiveRewards() internal override {\n        gauge.getReward();\n    }\n\n    /// @notice Removes part of the liquidity from DEX (amount/totalSupply)\n    function _withdrawFromDex(uint amount, uint totalSupply) internal override returns (uint amountA, uint amountB) {\n        emit TestValue(\"withdraw from dex amount\", amount);\n        emit TestValue(\"withdraw from dex total supply\", totalSupply);\n        uint toWithdraw = gauge.balanceOf(address(this)) * amount / totalSupply;\n        gauge.withdraw(toWithdraw);\n        (uint quoteA, uint quoteB) = router.quoteRemoveLiquidity(address(primary), address(secondary), stable, toWithdraw);\n        (uint withdrawnA, uint withdrawnB) = router.removeLiquidity(address(primary), address(secondary), stable, toWithdraw, quoteA, quoteB, address(this), block.timestamp);\n        amountA = withdrawnA;\n        amountB = withdrawnB;\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}